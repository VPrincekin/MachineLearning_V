### 使用Apriori(先验)算法进行关联分析

关联分析是一种在大规模数据集中寻找有趣关系的任务。 这些关系可以有两种形式:

    频繁项集（frequent item sets）: 经常出现在一块的物品的集合。
    关联规则（associational rules）: 暗示两种物品之间可能存在很强的关系。

Apriori 原理，即某个项集是频繁的，那么它的所有子集也是频繁的。 例如，如果 {0, 1} 是频繁的，那么 {0}, {1} 也是频繁的。
该原理直观上没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是 非频繁项集，那么它的所有超集也是非频繁项集。
使用该原理就可以避免项集数目的指数增长，从而在合理的时间内计算出频繁项集。

### 代码思路顺序：

**apriori ---> rules_apriori ---> aprioriDemo**

### 代码大致结构：

#### apriori模块：
    利用Apriori算法发现频繁项集核心代码。
    
    1. loadDataSet()
        创建了一个用于测试的简单数据集。
        
    2. createC1(dataSet)
        构建集合C1，C1是大小为1的所有候选项集的集合(不重复)。
        
    3. scanD(D, Ck, minSupport)
        该函数用于从C1生成L1(频繁项集列表)。另外，该函数会返回一个包含支持度值得字典以备后用。
    
    4. aprioriGen(Lk, k)
        输入频繁项集列表 Lk 与返回的元素个数 k，然后输出候选项集 Ck。
        例如: 以 {0},{1},{2} 为输入且 k = 2 则输出 {0,1}, {0,2}, {1,2}. 以 {0,1},{0,2},{1,2} 为输入且 k = 3 则输出 {0,1,2}
        仅需要计算一次，不需要将所有的结果计算出来，然后进行去重操作，这是一个更高效的算法
        
    5. apriori(dataSet, minSupport = 0.5)
        该函数首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。
        那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，
        C2 再进一步过滤变成 L2，然后以此类推，直到 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。
        
    6.  main
        测试Apriori算法的辅助函数（createC1、 scanD）
        测试完整的Apriori算法
        
#### rules_apriori模块：
    利用Apriori算法生成关联规则
    
    1. calcConf(freqSet, H, supportData, brl, minConf=0.7)
        对规则进行评估：计算规则的可信度以及找到满足最小可信度要求的规则。
        
    2. rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7)
        该函数是为了从最初的频繁项集中生成更多的规则。
         
    3. generateRules(L, supportData, minConf=0.7)
        主函数：生成关联规则，调用上面的两个函数
        
    4. main
        测试利用Apriori生成关联规则
        
#### aprioriDemo模块：
    一个小的案例：发现毒蘑菇的相似特征
        
        
        